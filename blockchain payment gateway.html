<!DOCTYPE html>
<html lang="en">// backend/server.js
const express = require("express");
const cors = require("cors");

const app = express();
const PORT = process.env.PORT || 4000;

// ----- Middleware -----
app.use(cors());             // allow frontend from GitHub Pages / localhost
app.use(express.json());     // parse JSON bodies

// ----- In-memory data (resets on server restart) -----
const payments = [
  {
    id: "INV-2041",
    customer: "Prime Crypto Store",
    amountEth: "0.42",
    fiat: "$1,305.00",
    network: "Sepolia",
    status: "Settled",
    statusType: "success",
    time: "12 min ago",
    txHash: "0x7dâ€¦a9f3",
    method: "ETH",
    memo: "Initial sample payment"
  },
  {
    id: "INV-2038",
    customer: "DeFi Analytics Pro",
    amountEth: "0.13",
    fiat: "$395.20",
    network: "Polygon",
    status: "Pending",
    statusType: "pending",
    time: "3 min ago",
    txHash: "0xa1â€¦b74c",
    method: "USDC",
    memo: "Subscription upgrade"
  }
];

// Simple ID generator
function nextInvoiceId() {
  const base = 2040 + payments.length + 1;
  return "INV-" + base;
}

// ----- Health check -----
app.get("/api/health", (req, res) => {
  res.json({
    status: "OK",
    time: new Date().toISOString()
  });
});

// ----- AI Stock Prediction endpoint (alias + legacy path) -----
app.post("/api/ai/stock-prediction", (req, res) => {
  const { prices } = req.body || {};

  if (!Array.isArray(prices) || prices.length === 0) {
    return res.status(400).json({ error: "prices must be a non-empty array of numbers" });
  }

  const n = prices.length;
  const returns = [];

  for (let i = 1; i < n; i++) {
    const prev = prices[i - 1];
    const cur = prices[i];
    if (prev <= 0) continue;
    returns.push((cur - prev) / prev);
  }

  if (returns.length === 0) {
    return res.status(400).json({ error: "not enough valid prices to compute returns" });
  }

  const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
  const variance =
    returns.reduce((acc, r) => acc + Math.pow(r - avgReturn, 2), 0) / returns.length;
  const volatility = Math.sqrt(variance);

  const lastPrice = prices[prices.length - 1];
  const predictedNextPrice = lastPrice * (1 + avgReturn);

  res.json({
    avgReturn,
    volatility,
    predictedNextPrice
  });
});

// Legacy alias: /api/stock/predict -> same logic
app.post("/api/stock/predict", (req, res) => {
  // just forward to the main handler
  req.url = "/api/ai/stock-prediction";
  app._router.handle(req, res);
});

// ----- Portfolio optimizer demo -----
app.post("/api/portfolio/optimize", (req, res) => {
  const { assets, riskTolerance = 0.5 } = req.body || {};

  if (!Array.isArray(assets) || assets.length === 0) {
    return res.status(400).json({ error: "assets must be a non-empty array" });
  }

  const n = assets.length;

  // Naive equal-weight baseline + risk-tolerance tilt towards higher return
  let totalScore = 0;
  const scores = assets.map(a => {
    const r = Number(a.expectedReturn || 0);
    const v = Number(a.risk || 1);
    const score = v <= 0 ? 0 : (r / v) ** (0.5 + riskTolerance); // higher r, lower v -> higher score
    totalScore += score;
    return score;
  });

  const weights = assets.map((asset, idx) => {
    const w = totalScore > 0 ? scores[idx] / totalScore : 1 / n;
    return {
      symbol: asset.symbol || `Asset ${idx + 1}`,
      weight: Number(w.toFixed(4))
    };
  });

  res.json({
    weights,
    riskTolerance,
    note: "Simple heuristic optimizer for demo purposes only."
  });
});

// ----- NEW: Payments API -----

// GET /api/payments -> list payments
app.get("/api/payments", (req, res) => {
  res.json({ payments });
});

// POST /api/payments -> log a new payment
app.post("/api/payments", (req, res) => {
  const {
    customer = "Demo Customer",
    amountEth,
    fiat,
    network = "Unknown",
    method = "ETH",
    memo = ""
  } = req.body || {};

  if (!amountEth || Number(amountEth) <= 0) {
    return res.status(400).json({ error: "amountEth must be > 0" });
  }

  const payment = {
    id: nextInvoiceId(),
    customer,
    amountEth: String(amountEth),
    fiat: fiat || "",
    network,
    status: "Logged",
    statusType: "pending",
    time: new Date().toISOString(),
    txHash: req.body.txHash || "0xlogged-via-api",
    method,
    memo
  };

  // Add to the top of the list
  payments.unshift(payment);

  return res.status(201).json(payment);
});

// ----- Start server -----
app.listen(PORT, () => {
  console.log(`Backend running on port ${PORT}`);
});

<head>
  <meta charset="UTF-8" />
  <title>Blockchain Payment Gateway | Christopher Alemao</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Fonts & Icons -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />

  <!-- React + ReactDOM + Babel (for JSX) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>

  <style>
    body {
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at top, #1f2937 0, #020617 45%, #000 100%);
      color: #e5e7eb;
      min-height: 100vh;
    }

    .glass-panel {
      background: linear-gradient(to bottom right, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 0.85));
      border-radius: 1.5rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow:
        0 30px 60px rgba(15, 23, 42, 0.8),
        0 0 40px rgba(56, 189, 248, 0.18);
      backdrop-filter: blur(18px);
    }

    .neon-pill {
      border-radius: 999px;
      border: 1px solid rgba(56, 189, 248, 0.4);
      box-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
    }

    .gradient-border {
      position: relative;
      border-radius: 1.25rem;
      padding: 1px;
      background: linear-gradient(135deg, rgba(56, 189, 248, 0.7), rgba(129, 140, 248, 0.7), rgba(16, 185, 129, 0.7));
    }

    .gradient-border-inner {
      border-radius: 1.2rem;
      background: rgba(15, 23, 42, 0.96);
    }

    .status-pill {
      border-radius: 999px;
      padding: 0.1rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .status-pill.success {
      background: rgba(22, 163, 74, 0.15);
      color: #4ade80;
      border: 1px solid rgba(34, 197, 94, 0.6);
    }

    .status-pill.pending {
      background: rgba(234, 179, 8, 0.15);
      color: #fde68a;
      border: 1px solid rgba(234, 179, 8, 0.6);
    }

    .status-pill.failed {
      background: rgba(220, 38, 38, 0.15);
      color: #fecaca;
      border: 1px solid rgba(239, 68, 68, 0.7);
    }
  </style>
</head>
<body class="text-slate-100">
  <!-- Top bar -->
  <div class="w-full border-b border-slate-800/70 bg-slate-950/70 backdrop-blur-xl">
    <div class="max-w-6xl mx-auto flex items-center justify-between px-4 py-4">
      <div class="flex items-center gap-3">
        <span
          class="inline-flex items-center justify-center w-9 h-9 rounded-xl bg-gradient-to-br from-cyan-400 to-emerald-400 text-slate-950 font-extrabold text-xl shadow-lg shadow-cyan-500/40">
          â‚¿
        </span>
        <div>
          <div class="text-xs uppercase tracking-[0.25em] text-slate-400">
            Christopher Alemao
          </div>
          <div class="text-sm font-semibold text-slate-100">
            Blockchain Payment Gateway
          </div>
        </div>
      </div>

      <div class="flex items-center gap-3 text-xs sm:text-sm">
        <a href="index.htm#projects"
           class="hidden sm:inline-flex items-center px-3 py-1.5 rounded-full border border-slate-700/80 text-slate-300 hover:bg-slate-800/80 transition">
          <i class="fa-solid fa-arrow-left mr-2 text-slate-400"></i>
          Back to Portfolio
        </a>

        <span class="inline-flex items-center px-3 py-1.5 neon-pill bg-slate-900/70 text-xs text-cyan-300">
          <span class="w-1.5 h-1.5 rounded-full bg-emerald-400 mr-1.5 animate-pulse"></span>
          Demo Â· Ethereum Â· Web3.js Â· React
        </span>
      </div>
    </div>
  </div>

  <!-- Root for React app -->
  <div id="root" class="max-w-6xl mx-auto px-4 py-8"></div>

  <script type="text/babel">
  const { useState, useEffect } = React;

  // Base URL for your backend API
  // When you deploy the backend (Render/Railway/etc.), change this to that URL.
  const API_BASE = "http://localhost:4000";

  const CHAIN_NAMES = {
    "0x1": "Ethereum Mainnet",
    "0x5": "Goerli",
    "0xaa36a7": "Sepolia",
    "0x89": "Polygon",
    "0x13881": "Mumbai"
  };

  // ðŸ‘‰ Replace this with your *testnet* merchant address for live test txs
  const MERCHANT_ADDRESS = "0x0000000000000000000000000000000000000000";

  const samplePayments = [
    {
      id: "INV-2041",
      customer: "Prime Crypto Store",
      amountEth: "0.42",
      fiat: "$1,305.00",
      network: "Sepolia",
      status: "Settled",
      statusType: "success",
      time: "12 min ago",
      txHash: "0x7dâ€¦a9f3",
      method: "ETH",
      memo: "Initial sample payment"
    },
    {
      id: "INV-2038",
      customer: "DeFi Analytics Pro",
      amountEth: "0.13",
      fiat: "$395.20",
      network: "Polygon",
      status: "Pending",
      statusType: "pending",
      time: "3 min ago",
      txHash: "0xa1â€¦b74c",
      method: "USDC",
      memo: "Subscription upgrade"
    },
    {
      id: "INV-2036",
      customer: "NFT Launchpad",
      amountEth: "0.87",
      fiat: "$2,707.80",
      network: "Sepolia",
      status: "Failed",
      statusType: "failed",
      time: "26 min ago",
      txHash: "0x4fâ€¦c892",
      method: "ETH",
      memo: "Payment failed"
    }
  ];

  function App() {
    const [web3, setWeb3] = useState(null);
    const [account, setAccount] = useState(null);
    const [chainId, setChainId] = useState(null);

    const [amountEth, setAmountEth] = useState("0.05");
    const [fiatAmount, setFiatAmount] = useState("150.00");
    const [currency, setCurrency] = useState("USD");
    const [asset, setAsset] = useState("ETH");
    const [memo, setMemo] = useState("Order #2042 â€“ Premium subscription");

    const [status, setStatus] = useState(
      "Connect a wallet to start a live crypto payment."
    );
    const [statusTone, setStatusTone] = useState("idle"); // idle | ok | pending | error | warning
    const [isPaying, setIsPaying] = useState(false);
    const [txHash, setTxHash] = useState(null);
    const [payments, setPayments] = useState(samplePayments);
    const [backendOnline, setBackendOnline] = useState(false);

    // ---- Wire up MetaMask listeners ----
    useEffect(() => {
      if (!window.ethereum) return;

      const handleAccountsChanged = (accounts) => {
        setAccount(accounts[0] || null);
      };

      const handleChainChanged = (cid) => {
        setChainId(cid);
      };

      window.ethereum.on("accountsChanged", handleAccountsChanged);
      window.ethereum.on("chainChanged", handleChainChanged);

      return () => {
        if (!window.ethereum.removeListener) return;
        window.ethereum.removeListener("accountsChanged", handleAccountsChanged);
        window.ethereum.removeListener("chainChanged", handleChainChanged);
      };
    }, []);

    // ---- Load payments from backend if available ----
    useEffect(() => {
      async function loadPayments() {
        try {
          const res = await fetch(`${API_BASE}/api/payments`);
          if (!res.ok) throw new Error("Non-200 from payments API");

          const data = await res.json();
          if (Array.isArray(data.payments)) {
            setPayments(data.payments);
            setBackendOnline(true);
            setStatus(
              "Loaded payments from backend API. Connect a wallet to create a new one."
            );
            setStatusTone("ok");
          }
        } catch (err) {
          console.log("Payments API not available, using sample data:", err.message);
          setBackendOnline(false);
          // keep samplePayments
        }
      }

      loadPayments();
    }, []);

    const connectWallet = async () => {
      if (!window.ethereum) {
        setStatus("No Web3 wallet detected. Install MetaMask to try the live flow.");
        setStatusTone("error");
        return;
      }

      try {
        const provider = window.ethereum;
        const accounts = await provider.request({ method: "eth_requestAccounts" });
        const cid = await provider.request({ method: "eth_chainId" });

        const w3 = new Web3(provider);
        setWeb3(w3);
        setAccount(accounts[0]);
        setChainId(cid);
        setStatus(
          backendOnline
            ? "Wallet connected. Payments will also be logged to the backend API."
            : "Wallet connected. Backend not detected, using local demo ledger."
        );
        setStatusTone("ok");
      } catch (err) {
        console.error(err);
        setStatus("Wallet connection cancelled.");
        setStatusTone("error");
      }
    };

    const handlePay = async (e) => {
      e.preventDefault();
      setTxHash(null);

      if (!web3 || !account) {
        setStatus("Please connect a wallet first.");
        setStatusTone("error");
        return;
      }

      if (!amountEth || Number(amountEth) <= 0) {
        setStatus("Enter a positive crypto amount.");
        setStatusTone("error");
        return;
      }

      const networkLabel = chainId
        ? CHAIN_NAMES[chainId] || `Chain ID ${parseInt(chainId, 16)}`
        : "Unknown";

      const weiValue = web3.utils.toWei(amountEth.toString(), "ether");

      const txParams = {
        from: account,
        to: MERCHANT_ADDRESS,
        value: weiValue
      };

      // Base payment object (used both for demo + backend logging)
      const paymentBase = {
        customer: "Demo Customer",
        amountEth,
        fiat: `${currency} ${fiatAmount}`,
        network: networkLabel,
        method: asset,
        memo
      };

      // DEMO MODE if merchant address is not set
      const demoMode = /^0x0{40}$/i.test(MERCHANT_ADDRESS);

      try {
        setIsPaying(true);
        setStatus("Preparing transactionâ€¦");
        setStatusTone("pending");

        let liveTxHash = null;

        if (!demoMode) {
          setStatus("Waiting for wallet confirmationâ€¦");
          liveTxHash = await window.ethereum.request({
            method: "eth_sendTransaction",
            params: [txParams]
          });
          setTxHash(liveTxHash);
          setStatus("Transaction submitted to the network.");
          setStatusTone("ok");
        } else {
          setStatus(
            "Demo mode: MERCHANT_ADDRESS not configured. Simulating payment + logging via API."
          );
          setStatusTone("warning");
        }

        // Try to log with backend API (if available)
        let savedPayment = null;

        if (backendOnline) {
          try {
            const res = await fetch(`${API_BASE}/api/payments`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                ...paymentBase,
                txHash: liveTxHash || "0xsimulated-demo"
              })
            });

            if (res.ok) {
              savedPayment = await res.json();
              setStatus((prev) =>
                prev + " Payment has been logged to the backend ledger."
              );
              setStatusTone("ok");
            } else {
              console.warn("POST /api/payments failed with", res.status);
            }
          } catch (err) {
            console.warn("Could not reach payments API, using local ledger only.", err);
          }
        }

        // Fallback: build a local payment row if API not available
        if (!savedPayment) {
          savedPayment = {
            id: "INV-" + (2042 + payments.length),
            ...paymentBase,
            status: demoMode ? "Simulated" : "Pending",
            statusType: demoMode ? "pending" : "pending",
            time: "Just now",
            txHash: liveTxHash
              ? liveTxHash.slice(0, 6) + "â€¦" + liveTxHash.slice(-4)
              : "0xsimulated-demo"
          };
        }

        // Update table
        setPayments((prev) => [savedPayment, ...prev]);
      } catch (err) {
        console.error(err);
        setStatus(err?.message || "Payment rejected or failed.");
        setStatusTone("error");
      } finally {
        setIsPaying(false);
      }
    };

    const networkLabel = chainId
      ? CHAIN_NAMES[chainId] || `Chain ID ${parseInt(chainId, 16)}`
      : "No network";

    const settlementVolume = payments
      .reduce((acc, p) => acc + Number(p.amountEth || 0), 0)
      .toFixed(2);

    return (
      <div className="space-y-6 pb-10">
        {/* Hero / context */}
        <div className="glass-panel px-6 py-5 sm:px-8 sm:py-6 flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <div>
            <div className="inline-flex items-center px-2.5 py-1 rounded-full bg-slate-900/80 border border-slate-700/60 text-xs text-slate-300 mb-3">
              <i className="fa-solid fa-shield-halved mr-2 text-emerald-400"></i>
              Secure Ethereum payments Â· Smart contracts Â· Real-time settlement
            </div>
            <h1 className="text-xl sm:text-2xl font-semibold text-slate-50 mb-1">
              Fin-Viz Dashboard Â· Blockchain Payment Gateway
            </h1>
            <p className="text-sm text-slate-400 max-w-2xl">
              React + Web3.js front-end that can connect to any EVM wallet and generate
              Ethereum-based payments. A Node.js backend API logs each payment to a CRM-style ledger.
              In this portfolio demo, everything runs on free tiers and testnet-friendly settings.
            </p>
          </div>

          <div className="text-right space-y-2">
            <button
              onClick={connectWallet}
              className="inline-flex items-center px-4 py-2.5 rounded-xl bg-gradient-to-r from-cyan-400 to-emerald-400 text-slate-950 font-semibold text-sm shadow-lg shadow-cyan-500/40 hover:shadow-emerald-500/40 hover:scale-[1.01] transition"
            >
              <i className="fa-brands fa-ethereum mr-2"></i>
              {account ? "Wallet Connected" : "Connect Wallet"}
            </button>
            <div className="text-[10px] text-slate-400">
              {account ? (
                <>
                  <span className="font-mono text-emerald-300 mr-2">
                    {account.slice(0, 6)}â€¦{account.slice(-4)}
                  </span>
                  <span className="text-slate-500">on {networkLabel}</span>
                </>
              ) : (
                <>No wallet connected</>
              )}
            </div>
            <div className="text-[10px] text-slate-500">
              Backend:{" "}
              <span className={backendOnline ? "text-emerald-300" : "text-slate-400"}>
                {backendOnline ? "Online" : "Not detected (using local demo data)"}
              </span>
            </div>
          </div>
        </div>

        {/* Main layout (same as before, but now using `payments` state) */}
        {/* ---- everything from here down can stay identical to the previous version,
                *using the same JSX you already have*,
                because we didn't change the table or metrics structure ---- */}

        {/* For brevity, keep your existing JSX for:
              - metrics cards
              - payments table (reads from `payments`)
              - right-side form (uses handlePay)
              - status panel (uses status/statusTone/txHash)
            It will now be powered by the updated logic above. */}
      </div>
    );
  }

  ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>

</body>
</html>
